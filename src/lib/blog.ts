
'use server';

import connectToDatabase from '@/lib/mongodb';
import type { BlogPost, NewBlogPost } from '@/types/blog';
import { ObjectId } from 'mongodb';

// Local helper function, not exported
function generateSlug(title: string): string {
  return title
    .toLowerCase()
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(/[^\w-]+/g, '') // Remove all non-word chars (alphanumeric, underscore, hyphen)
    .replace(/--+/g, '-') // Replace multiple - with single -
    .replace(/^-+/, '') // Trim - from start of text
    .replace(/-+$/, ''); // Trim - from end of text
}

// Helper to map MongoDB document to BlogPost type
function mapDocumentToBlogPost(doc: any): BlogPost {
  if (!doc) return doc; // Handles case where doc might be null
  return {
    id: doc._id.toString(),
    slug: doc.slug,
    title: doc.title,
    author: doc.author,
    date: doc.date, // Assuming date is stored as ISO string or Date object compatible with it
    content: doc.content,
    excerpt: doc.excerpt,
  };
}

export async function getAllPosts(): Promise<BlogPost[]> {
  try {
    const { blogsCollection } = await connectToDatabase();
    const postsDocs = await blogsCollection.find({}).sort({ date: -1 }).toArray();
    return postsDocs.map(mapDocumentToBlogPost);
  } catch (error) {
    console.error('Failed to fetch blog posts from MongoDB:', error);
    return [];
  }
}

export async function getPostBySlug(slug: string): Promise<BlogPost | undefined> {
  try {
    const { blogsCollection } = await connectToDatabase();
    const postDoc = await blogsCollection.findOne({ slug });
    return postDoc ? mapDocumentToBlogPost(postDoc) : undefined;
  } catch (error) {
    console.error(`Failed to get post by slug ${slug} from MongoDB:`, error);
    return undefined;
  }
}

export async function getPostById(id: string): Promise<BlogPost | undefined> {
  if (!ObjectId.isValid(id)) {
    console.error(`Invalid ObjectId format for ID ${id}`);
    return undefined;
  }
  try {
    const { blogsCollection } = await connectToDatabase();
    const postDoc = await blogsCollection.findOne({ _id: new ObjectId(id) });
    return postDoc ? mapDocumentToBlogPost(postDoc) : undefined;
  } catch (error) {
    console.error(`Failed to get post by ID ${id} from MongoDB:`, error);
    return undefined;
  }
}

export async function addPost(newPostData: NewBlogPost): Promise<BlogPost> {
  const { blogsCollection } = await connectToDatabase();
  
  let slug = generateSlug(newPostData.title);
  let counter = 1;
  // Ensure slug uniqueness
  while (await blogsCollection.findOne({ slug })) {
    slug = `${generateSlug(newPostData.title)}-${counter}`;
    counter++;
  }

  const postToInsert = {
    // _id will be generated by MongoDB
    slug: slug,
    title: newPostData.title,
    author: newPostData.author || 'Admin',
    date: new Date().toISOString(),
    content: newPostData.content,
    excerpt: newPostData.excerpt || newPostData.content.substring(0, 150) + (newPostData.content.length > 150 ? '...' : ''),
  };

  try {
    const result = await blogsCollection.insertOne(postToInsert);
    if (!result.insertedId) {
      throw new Error('MongoDB insertion failed, no ID returned.');
    }
    const insertedDoc = await blogsCollection.findOne({ _id: result.insertedId });
    if (!insertedDoc) {
        throw new Error('Failed to retrieve inserted document from MongoDB.');
    }
    return mapDocumentToBlogPost(insertedDoc);
  } catch (error) {
    console.error('Failed to add blog post to MongoDB:', error);
    throw new Error('Could not save the blog post to MongoDB.');
  }
}

export async function updatePost(postId: string, dataToUpdate: NewBlogPost): Promise<BlogPost | null> {
  if (!ObjectId.isValid(postId)) {
    console.error(`Invalid ObjectId format for postId ${postId} in updatePost`);
    return null;
  }
  const { blogsCollection } = await connectToDatabase();
  const objectId = new ObjectId(postId);

  const originalPostDoc = await blogsCollection.findOne({ _id: objectId });
  if (!originalPostDoc) {
    console.error(`Post with ID ${postId} not found for update in MongoDB.`);
    return null;
  }

  const updatePayload: Partial<Omit<BlogPost, 'id' | 'date'>> & { date?: string } = { ...dataToUpdate };

  if (dataToUpdate.title && dataToUpdate.title !== originalPostDoc.title) {
    let newSlug = generateSlug(dataToUpdate.title);
    let counter = 1;
    // Ensure new slug is unique among OTHER posts
    while (await blogsCollection.findOne({ slug: newSlug, _id: { $ne: objectId } })) {
      newSlug = `${generateSlug(dataToUpdate.title)}-${counter}`;
      counter++;
    }
    updatePayload.slug = newSlug;
  }
  
  if (dataToUpdate.content || !dataToUpdate.excerpt) {
      updatePayload.excerpt = dataToUpdate.excerpt || dataToUpdate.content.substring(0,150) + (dataToUpdate.content.length > 150 ? '...' : '');
  }
  
  updatePayload.author = dataToUpdate.author || originalPostDoc.author || 'Admin';
  // The 'date' field is generally not updated unless specifically intended.
  // If you want to update 'date' on every edit, you could add: updatePayload.date = new Date().toISOString();

  try {
    const result = await blogsCollection.findOneAndUpdate(
      { _id: objectId },
      { $set: updatePayload },
      { returnDocument: 'after' }
    );
    
    if (!result) {
        console.error(`Failed to update post or post not found (ID: ${postId}) in MongoDB.`);
        return null;
    }
    return mapDocumentToBlogPost(result);
  } catch (error) {
    console.error(`Failed to update blog post (ID: ${postId}) in MongoDB:`, error);
    throw new Error('Could not update the blog post in MongoDB.');
  }
}

export async function deletePost(postId: string): Promise<boolean> {
  if (!ObjectId.isValid(postId)) {
    console.error(`Invalid ObjectId format for postId ${postId} in deletePost`);
    return false;
  }
  const { blogsCollection } = await connectToDatabase();
  const objectId = new ObjectId(postId);

  try {
    const result = await blogsCollection.deleteOne({ _id: objectId });
    if (result.deletedCount === 1) {
      return true;
    } else {
      console.warn(`Post with ID ${postId} not found for deletion in MongoDB or delete failed.`);
      return false;
    }
  } catch (error) {
    const underlyingErrorMessage = error instanceof Error ? error.message : String(error);
    console.error(`Failed to delete blog post (ID: ${postId}) from MongoDB. Error:`, underlyingErrorMessage, error);
    // Re-throw a more generic error for the action handler
    throw new Error(`Could not delete the blog post from MongoDB. Details: ${underlyingErrorMessage}`);
  }
}
